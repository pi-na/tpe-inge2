Arquitectura del Sistema

Objetivo y alcance
- Plataforma DAM que: preserva másteres; genera rendiciones multiformato; enriquece con IA (labels, OCR, ASR, escenas); ofrece búsqueda rápida y segura; escala horizontalmente con alta disponibilidad y auditabilidad.

Principios y restricciones
- IaaS-only (VMs, storage bloques/objetos, redes, LB básicos); sin PaaS/SaaS gestionados.
- Separación de responsabilidades; máster inmutable; rendiciones reproducibles.
- Escalado horizontal con workers sin estado y colas.
- Zero-trust interno: mTLS, segmentación, cifrado en tránsito y reposo.
- Observabilidad/auditoría centralizadas.

Vista lógica (capas y componentes)
- Frontends: portal editores/admin, endpoints de entrega, API para automatización.
- API Gateway ligero (Nginx/HAProxy en VMs) con TLS, rate limit; Auth OIDC (Keycloak).
- Servicio de Ingesta: uploads resumibles, validación de hash/política; encola tareas.
- Almacenamiento de Máster: bucket objetos (Ceph/Swift/S3-compatible), versionado, WORM opcional, cifrado.
- Generación de Rendiciones: workers FFmpeg (CPU/GPU) con perfiles (1080p/720p, AAC, thumbnails, sprites); escribe en bucket de rendiciones y opcional CDN/cache (Nginx/Varnish).
- Metadatos/Catálogo: Metadata Service + PostgreSQL replicado (Asset, Version, Rendition, Channel, Policy, Audit).
- Indexación/Búsqueda: Search Service + OpenSearch/Elasticsearch autogestionado; índices de metadatos e IA; sharding/replicas.
- Enriquecimiento IA: workers OCR/ASR/escenas/visión sobre GPUs opcionales; guarda en metadatos e indexa; modelos en ONNX/TF Serving en VMs.
- Delivery: firma URLs temporales, aplica políticas por canal; sirve HLS/DASH e imágenes/audio; conectores a canales (webhook/FTP/S3-push) desacoplados.
- Seguridad: Policy Enforcement (RBAC/ABAC) en gateway/delivery; KMS propio (Vault/barbican-like); cifrado en reposo y tránsito; auditoría.
- Observabilidad: Prometheus+Grafana; logs (Loki/ELK); trazas (Jaeger/Zipkin); alertas por colas, transcode, IA, búsqueda y storage.

Flujos principales
- Ingesta: editor → Gateway → Ingesta → bucket máster; registra Asset pending; encola transcode+IA; al completar rendición requerida → ready e indexación base.
- Rendiciones: worker lee máster, transcodifica, escribe rendición, actualiza catálogo, publica evento, purga/invalida cache si aplica.
- IA: worker lee máster, corre modelos, guarda en metadatos, reindexa en búsqueda.
- Búsqueda/recuperación: usuario consulta; gateway autentica/políticas; Search responde; Delivery emite URL firmada HLS/DASH o enlace directo.
- Distribución multicanal: editor elige canal; conector aplica preset; publica vía webhook/FTP/S3; registra auditoría y estado.

Vista de despliegue físico (consigna)
- Red: VPC con subred pública (LB/edge) y privadas (servicios, datos); SG: edge→API→app→data; mTLS interno.
- Balanceo: LB L4/L7 (HAProxy/Nginx) HA en 2+ zonas.
- Cómputo: VMs API/Frontend (escala por CPU/requests); pool transcode (CPU/GPU) escala por profundidad de cola; pool IA escala por throughput.
- Almacenamiento: máster en objetos Ceph/Swift (rep 3x, WORM opcional); rendiciones en pool separado (rep 2x); metadatos en PostgreSQL replicado (writer+readers, PITR); búsqueda en OpenSearch/Elasticsearch (3+ master elegibles, hot/warm); cola RabbitMQ/Kafka (3 nodos); secretos en Vault HA.
- Edge/Cache: Nginx/Varnish en subred pública; TLS offload interno.
- Observabilidad: Prometheus, Grafana, Loki/ELK, Jaeger; logs a objetos para retención larga.

Decisiones y justificación
- Objetos para máster/rendiciones: mejor durabilidad/escala para archivos grandes; se descarta NAS/Gluster por overhead.
- FFmpeg en VMs: cumple IaaS y evita lock-in de servicios de media gestionados.
- OpenSearch/Elasticsearch autogestionado: ecosistema maduro; Solr viable pero más complejidad mixta.
- RabbitMQ/Kafka: desacopla y da backpressure; sincronía directa descartada.
- PostgreSQL para catálogo: integridad relacional; NoSQL puro descartado.
- Edge cache propio: independencia de CDN propietaria; se puede agregar CDN pública luego.
- Modelos IA en VMs: evita lock-in; intercambiables.
- mTLS + KMS propio: menor dependencia que KMS gestionado (prohibido por consigna).

Alineación con atributos
- Performance: cache edge, perfiles optimizados, búsqueda distribuida, colas para picos, GPU opcional.
- Disponibilidad: réplicas en datos, nodos redundantes, colas quorum, dominios de fallo.
- Seguridad: TLS/mTLS, cifrado reposo, tokens+políticas, auditoría.
- Escalabilidad: pools horizontales, sharding/replicas, objetos elásticos.
- Auditabilidad: logs centralizados, trazas, auditoría de accesos/cambios.
- Interoperabilidad: APIs REST/JSON, NDJSON para ingest/index, conectores webhook/FTP/S3, formatos estándar (HLS/DASH, MP4/H.264, AAC, PNG/JPEG).

Puntos críticos y mitigaciones
- Larga duración: replicación 3x, WORM, checksums, lifecycle a frío interno.
- Recuperación de archivos grandes: edge cache, pool de rendiciones dedicado, range requests, bitrates adaptados.
- Indexación IA: colas por modelo, versionado de modelos/resultados, asíncrono.
- Búsqueda rápida: campos normalizados + full-text, sharding balanceado, réplicas calientes, cache de queries.
- Multicanal: conectores desacoplados, políticas por canal, retries/backoff, URLs firmadas.
- Escalabilidad: autoscaling por métricas, particionado de índices/buckets, stateless workers.
- Disponibilidad/confiabilidad: HA en LB/API/colas/DB; backups+PITR; tests de failover.
- Seguridad: mTLS, RBAC/ABAC, KMS propio, aislamiento de red, hardening.
- Auditabilidad: accesos/cambios registrados; logs append-only.
- Interoperabilidad: estándares abiertos, sin dependencias propietarias; portable a cualquier IaaS.

Tecnologías sugeridas (IaaS-friendly)
- Edge/API: Nginx/HAProxy; Keycloak.
- Ingesta: tusd o propio Go/Node/Java; SHA-256.
- Cola: RabbitMQ o Kafka autogestionado.
- Transcode: FFmpeg; NVENC/VAAPI opcional.
- Objetos: Ceph RGW o Swift.
- Catálogo: PostgreSQL (Patroni/replica nativa).
- Búsqueda: OpenSearch/Elasticsearch.
- IA: ONNX Runtime/TF Serving; OCR (Tesseract/TrOCR), ASR (Whisper), visión (YOLO/CLIP).
- Observabilidad: Prometheus, Grafana, Loki/ELK, Jaeger.
- Secrets/KMS: HashiCorp Vault.

Riesgos y trade-offs
- Costo operativo de clústeres; mitigar con automatización y observabilidad.
- Complejidad operativa al evitar servicios gestionados; mitigar con playbooks.
- Latencia IA en picos; mitigar con colas dedicadas, batching, GPUs.
- Consistencia catálogo/índices; mitigar con eventos idempotentes y reindexación.
- CDN pública opcional; mantener cache propio para independencia.

