\section{Arquitectura del Sistema}

\subsection{Objetivo y alcance}
La arquitectura propuesta habilita una plataforma de Gestión de Activos Digitales (DAM) para medios de comunicación que: (i) almacena y preserva a largo plazo audio, imágenes y video en calidad máster; (ii) genera y distribuye rendiciones (derivados) en múltiples formatos y canales; (iii) enriquece e indexa el contenido con IA (etiquetas, OCR, speech-to-text, detección de escenas); (iv) ofrece búsqueda rápida y segura sobre millones de objetos; (v) escala horizontalmente y mantiene alta disponibilidad cumpliendo los atributos de calidad priorizados (performance, disponibilidad, seguridad, escalabilidad, auditabilidad, interoperabilidad).

\subsection{Principios y restricciones}
\begin{itemize}
    \item \textbf{Infraestructura IaaS-only}: sólo se usan máquinas virtuales, almacenamiento de bloques/objetos, redes virtuales y balanceadores básicos. No se emplean servicios gestionados PaaS/SaaS (evita vendor lock-in y respeta la consigna).
    \item \textbf{Separación de responsabilidades}: ingestión, procesamiento de media, metadatos, indexación/búsqueda y delivery se desacoplan.
    \item \textbf{Data-first}: los másteres son inmutables; las rendiciones son reproducibles (infra como código para pipelines).
    \item \textbf{Escalado horizontal}: workers sin estado, colas distribuidas y almacenamiento compartido.
    \item \textbf{Zero-trust interno}: autenticación mutua entre servicios, red segmentada, cifrado en tránsito y en reposo.
    \item \textbf{Observabilidad y auditoría}: trazas, métricas y logs centralizados; auditoría de accesos a activos y cambios de metadatos.
\end{itemize}

\subsection{Vista lógica (capas y componentes)}
\begin{itemize}
    \item \textbf{Frontends}: Portal web para editores y administradores (gestión, búsqueda, aprobación), y endpoints de entrega para consumo público/embeds; clientes opcionales de automatización (API).
    \item \textbf{APIs de borde}: \textit{API Gateway ligero} (Nginx/HAProxy en VMs) expone APIs REST/HTTPS; termina TLS y aplica rate limiting básico. Autenticación via OAuth2/OIDC con un \textit{IdP} propio (Keycloak en VMs) y emisión de tokens JWT.
    \item \textbf{Servicio de Ingesta}: recibe cargas grandes vía resumable upload (tus/HTTP chunked); valida checksums, tipo MIME y políticas; coloca referencias en la \textit{cola de orquestación}. Persiste manifiestos de ingesta (estado, usuario, hashes).
    \item \textbf{Almacenamiento de Máster}: bucket de objetos autoscalable en IaaS (p.\,ej. Ceph/S3-compatible o Swift en VMs) para archivos maestros (video 4K/AVI, audio WAV, imágenes RAW). Versionado y cifrado en reposo (AES-256). Política WORM para preservar másteres.
    \item \textbf{Generación de Rendiciones}: pool de \textit{workers transcodificadores} (FFmpeg en VMs con aceleración opcional GPU) que consumen tareas de la cola; perfiles predefinidos (web 1080p MP4/H.264, mobile 720p, audio AAC, thumbnails, sprites) y on-the-fly si se solicita un formato inexistente (se cachea). Rendiciones se escriben en \textbf{Almacenamiento de Rendiciones} (bucket de objetos de baja latencia) y se publican a la \textbf{CDN} opcional (Nginx reverse cache o Varnish en VMs).
    \item \textbf{Metadatos y Catálogo}: \textit{Metadata Service} con base relacional (PostgreSQL en VMs, replicada) para entidades: Asset, Version, Rendition, Channel, Policy, Audit. Garantiza integridad y transaccionalidad en altas/bajas/modificaciones editoriales.
    \item \textbf{Indexación y Búsqueda}: \textit{Search Service} con clúster autosostenido de búsqueda (OpenSearch/Elasticsearch auto-gestionado en VMs) indexa campos estructurados y no estructurados (full-text, etiquetas, escenas, timestamps). Ingesta en dos fases: (1) metadatos atómicos; (2) resultados de IA. Sharding y replicas configurables; warm nodes para índices fríos.
    \item \textbf{Enriquecimiento con IA}: pipeline asíncrono con \textit{workers de IA} (OCR, ASR, detección de escenas, etiquetas visuales). Los modelos pueden correr en GPU VMs; resultados se guardan en \textit{Metadata Service} (estructura normalizada) y se indexan. Se desacopla proveedor de modelo (ONNX Runtime/TF Serving en VMs); evita servicios gestionados.
    \item \textbf{Distribución y Delivery}: \textit{Delivery Service} firma URLs temporales, aplica control de acceso por canal/política, y sirve desde almacenamiento de rendiciones + capa de edge cache (Nginx/Varnish). Soporta HLS/DASH para video, y entrega directa de imágenes/audio. Puede publicar a múltiples canales (web, apps, redes sociales) vía conectores (webhooks/FTP/S3-compatible push) encapsulados en workers específicos.
    \item \textbf{Seguridad y Cumplimiento}: módulo de \textit{Policy Enforcement} (ABAC/RBAC) aplicado en API Gateway y en Delivery; cifrado en reposo (LUKS/FS-level + SSE en objetos); KMS propio (HashiCorp Vault o barbican-like en VMs) para llaves. Auditoría central de accesos a activos y cambios de metadatos.
    \item \textbf{Observabilidad}: stack auto-gestionado (Prometheus + Grafana en VMs; Loki/ELK para logs; Jaeger/Zipkin para trazas). Alertas sobre colas, tiempos de transcodificación, errores de IA, latencia de búsqueda y saturación de storage.
\end{itemize}

\subsection{Flujos principales}
\paragraph{Ingesta y preservación}
\begin{enumerate}
    \item Usuario editor inicia carga vía frontend → API Gateway → Ingesta.
    \item Upload resumable al almacenamiento de máster; se validan hash y política.
    \item Se registra el Asset (estado \textit{pending}) y se encola tarea de transcodificación y enriquecimiento.
    \item Al completarse al menos una rendición requerida, el Asset pasa a \textit{ready}; se indexan metadatos base.
\end{enumerate}

\paragraph{Generación de rendiciones}
\begin{enumerate}
    \item Worker toma tarea, lee máster desde el bucket de máster.
    \item Ejecuta perfil FFmpeg; escribe rendición en bucket de rendiciones.
    \item Actualiza catálogo (nueva Rendition) y publica evento de indexación.
    \item CDN/edge cache purga/invalida si aplica.
\end{enumerate}

\paragraph{Enriquecimiento IA}
\begin{enumerate}
    \item Worker IA consume tarea; ejecuta OCR/ASR/detección de escenas.
    \item Guarda resultados estructurados en metadatos; envía a Search para reindexar campos semánticos y temporales.
\end{enumerate}

\paragraph{Búsqueda y recuperación}
\begin{enumerate}
    \item Usuario consulta; API Gateway autentica y aplica políticas.
    \item Search responde con hits y highlights; para reproducción, Delivery genera URL firmada HLS/DASH o enlace directo a imagen/audio.
\end{enumerate}

\paragraph{Distribución multicanal}
\begin{enumerate}
    \item Editor selecciona canal; Delivery/Conector aplica formato/preset del canal.
    \item Publica por webhook/FTP/S3-compatible; registra auditoría y estado.
\end{enumerate}

\subsection{Vista de despliegue físico (requerida por la consigna)}
\begin{itemize}
    \item \textbf{Red}: VPC con subred pública (LB/edge) y privadas (servicios, datos). Grupos de seguridad segmentan: \{edge\} → \{API\} → \{app\} → \{data\}. Todo tráfico interno cifrado (mTLS).
    \item \textbf{Balanceo}: LB L4/L7 en VMs (HAProxy/Nginx) en alta disponibilidad (2+ zonas).
    \item \textbf{Cómputo}: VMs para API/Frontend (autoescalado por CPU/requests); pool de VMs transcodificadoras (tipo general + GPU opcional) escaladas por profundidad de cola; pool IA (GPU/CPU) escaladas por throughput.
    \item \textbf{Almacenamiento}: máster en clúster de objetos (Ceph/Swift) con replicación 3x y WORM opcional; rendiciones en pool de objetos separado (replicación 2x); metadatos en PostgreSQL replicado (1 writer + 2 readers) con PITR; búsqueda en OpenSearch/Elasticsearch (3+ master elegibles, data hot/warm); cola en RabbitMQ/Kafka (3 nodos, quorum); secretos en Vault HA.
    \item \textbf{Edge/Cache}: Nginx/Varnish en subred pública para contenido estático/HLS/DASH; TLS offload con certificados gestionados internamente.
    \item \textbf{Observabilidad}: Prometheus + Grafana + Loki/ELK + Jaeger en VMs dedicadas; almacenamiento de logs en objetos para retención prolongada.
\end{itemize}

\subsection{Decisiones arquitectónicas y justificación}
\begin{itemize}
    \item \textbf{Buckets de objetos para máster y rendiciones}: optimizan costos y durabilidad para archivos grandes e inmutables; evitamos filesystems POSIX distribuidos complejos. Alternativa (NAS/GlusterFS) descartada por menor escalabilidad y mayor overhead.
    \item \textbf{FFmpeg en VMs vs. servicio gestionado}: cumple restricción IaaS, control total de perfiles y códecs; PaaS (MediaConvert/ElasticTranscoder) descartado por lock-in y restricción de consigna.
    \item \textbf{OpenSearch/Elasticsearch auto-gestionado}: búsqueda full-text y facetada, escalable y conocida; alternativa (Solr) viable pero menor ecosistema en pipelines de logs/metrics y mayor complejidad operativa mixta.
    \item \textbf{RabbitMQ/Kafka}: desacopla ingesta, transcodificación e IA; habilita reintentos y backpressure. Alternativa sin cola (sincronía directa) descartada por fragilidad y poca elasticidad.
    \item \textbf{PostgreSQL para catálogo}: garantiza integridad y joins consistentes; NoSQL puro descartado para las relaciones fuertes (Asset-Version-Rendition-Policy).
    \item \textbf{Edge cache en VMs}: mantiene independencia de CDN propietaria; se puede poner frente a un CDN público si se autoriza más adelante.
    \item \textbf{Modelos IA en VMs}: evita servicios de IA gestionados; se pueden intercambiar motores (ONNX/TF) sin lock-in.
    \item \textbf{mTLS y KMS propio}: reduce exposición y dependencia; alternativa (KMS gestionado) rechazada por restricción de consigna.
\end{itemize}

\subsection{Alineación con atributos de calidad}
\begin{itemize}
    \item \textbf{Performance}: edge cache, rendiciones optimizadas, búsqueda distribuida, colas para suavizar picos, aceleración GPU opcional.
    \item \textbf{Disponibilidad}: replicas en datos (PostgreSQL, objetos, búsqueda), nodos redundantes en LB/API/workers, colas con quorum, dominios de fallo separados.
    \item \textbf{Seguridad}: cifrado en tránsito (TLS/mTLS), cifrado en reposo, KMS propio, control de acceso por token y política, auditoría de accesos.
    \item \textbf{Escalabilidad}: pools horizontales de API, transcodificación, IA y búsqueda; sharding y réplicas; almacenamiento de objetos elástico.
    \item \textbf{Auditabilidad}: logs centralizados, trazas distribuídas, auditoría de cambios y accesos a activos.
    \item \textbf{Interoperabilidad}: APIs REST con JSON/NDJSON para ingesta e indexación; conectores de salida (webhook/FTP/S3-compatible); formatos estándar (HLS/DASH, MP4/H.264, AAC, PNG/JPEG).
\end{itemize}

\subsection{Puntos críticos y mitigaciones}
\begin{itemize}
    \item \textbf{Almacenamiento a largo plazo}: objetos replicados 3x, WORM opcional, verificación de checksums; lifecycle hacia clases frías para másteres antiguos (dentro del mismo clúster).
    \item \textbf{Recuperación rápida de archivos grandes}: edge cache + bucket de rendiciones separado, presets de bitrate adaptados, range requests habilitadas.
    \item \textbf{Indexación con IA}: pipeline asíncrono, colas separadas por tipo de modelo, versionado de modelos y de resultados en metadatos.
    \item \textbf{Búsqueda rápida}: índices con campos normalizados + full-text, sharding balanceado, réplicas calientes, caching de consultas frecuentes.
    \item \textbf{Distribución multicanal}: conectores desacoplados; políticas por canal; retries con backoff; firma de URLs y expiración.
    \item \textbf{Escalabilidad}: autoscaling por métricas (cola, CPU, latencia); particionado de índices y buckets; workers sin estado.
    \item \textbf{Disponibilidad y confiabilidad}: HA en LB, API, colas, DB con failover; backups y PITR; pruebas de conmutación periódicas.
    \item \textbf{Seguridad}: mTLS interno, RBAC/ABAC, KMS propio, auditoría, aislamiento de red; hardening de imágenes base.
    \item \textbf{Auditabilidad}: todos los accesos a activos y cambios de metadatos se registran; retención en almacén de logs de solo append.
    \item \textbf{Interoperabilidad}: estándares abiertos en APIs y formatos; sin dependencias propietarias; despliegue portable en cualquier IaaS.
\end{itemize}

\subsection{Tecnologías sugeridas (IaaS-friendly)}
\begin{itemize}
    \item \textbf{Edge/API}: Nginx/HAProxy, Keycloak.
    \item \textbf{Ingesta}: tusd o módulo propio en Go/Node/Java; checksum SHA-256.
    \item \textbf{Cola}: RabbitMQ o Kafka auto-gestionado.
    \item \textbf{Transcodificación}: FFmpeg; opcional NVENC/VAAPI en GPU VMs.
    \item \textbf{Almacenamiento de objetos}: Ceph RGW o Swift.
    \item \textbf{Catálogo}: PostgreSQL con Patroni/replicación nativa.
    \item \textbf{Búsqueda}: OpenSearch/Elasticsearch auto-gestionado.
    \item \textbf{IA}: ONNX Runtime/TF Serving; modelos OCR (Tesseract/TrOCR), ASR (Whisper), visión (YOLO/CLIP).
    \item \textbf{Observabilidad}: Prometheus, Grafana, Loki/ELK, Jaeger.
    \item \textbf{Secrets/KMS}: HashiCorp Vault.
\end{itemize}

\subsection{Riesgos y trade-offs}
\begin{itemize}
    \item \textbf{Costo operativo} de operar clústeres (búsqueda, objetos, colas); mitigación: automatizar despliegue (Ansible/Terraform), observabilidad temprana.
    \item \textbf{Complejidad de operación} al evitar servicios gestionados; mitigación: patrones conocidos, playbooks de fallos y backups.
    \item \textbf{Latencia de IA} en picos; mitigación: colas dedicadas, batching y GPUs elásticas.
    \item \textbf{Consistencia entre catálogo e índices}: usar eventos idempotentes y reindexaciones periódicas.
    \item \textbf{CDN opcional}: si se agrega CDN pública, mantener cache propio como capa de independencia.
\end{itemize}

\subsection{Diagramas (PlantUML, vista arquitectónica exigida)}

\paragraph{Diagrama de componentes}
\begin{verbatim}
@startuml
rectangle Edge {
  [Web/Embeds]
  [API Gateway]
  [Keycloak]
}
rectangle App {
  [Ingesta Service]
  [Delivery Service]
  [Metadata Service]
  [Search Service]
  [Transcode Workers]
  [IA Workers]
  [Connectores Multicanal]
}
rectangle Data {
  [Bucket Maestros]
  [Bucket Rendiciones]
  [PostgreSQL]
  [OpenSearch]
  [Cola (RabbitMQ/Kafka)]
  [Vault/KMS]
}
[Web/Embeds] --> [API Gateway]
[API Gateway] --> [Ingesta Service]
[API Gateway] --> [Delivery Service]
[API Gateway] --> [Metadata Service]
[Ingesta Service] --> [Bucket Maestros]
[Ingesta Service] --> [Cola (RabbitMQ/Kafka)]
[Transcode Workers] --> [Bucket Maestros]
[Transcode Workers] --> [Bucket Rendiciones]
[Transcode Workers] --> [Metadata Service]
[Transcode Workers] --> [Cola (RabbitMQ/Kafka)]
[IA Workers] --> [Bucket Maestros]
[IA Workers] --> [Metadata Service]
[IA Workers] --> [OpenSearch]
[Search Service] --> [OpenSearch]
[Metadata Service] --> [PostgreSQL]
[Delivery Service] --> [Bucket Rendiciones]
[Delivery Service] --> [Connectores Multicanal]
[API Gateway] --> [Keycloak]
[App] --> [Vault/KMS]
@enduml
\end{verbatim}

\paragraph{Diagrama de despliegue}
\begin{verbatim}
@startuml
node "VPC" {
  node "Subred Pública" {
    node "LB/Edge VMs" as edge
    node "Cache (Nginx/Varnish) VMs" as cache
  }
  node "Subred Servicios" {
    node "API/Frontend VMs" as api
    node "Ingesta VMs" as ing
    node "Delivery VMs" as deliv
    node "Workers Transcode" as tx
    node "Workers IA" as ia
    node "Keycloak VMs" as kc
  }
  node "Subred Datos" {
    node "PostgreSQL (HA)" as pg
    node "OpenSearch Cluster" as es
    node "RabbitMQ/Kafka (3 nodos)" as mq
    node "Vault (HA)" as vault
    node "Ceph/Swift RGW (Maestros)" as mstore
    node "Ceph/Swift RGW (Rendiciones)" as rstore
  }
}
edge --> cache : TLS 443
cache --> api : mTLS 443
api --> ing : mTLS
api --> deliv : mTLS
api --> kc : OIDC
ing --> mstore : S3/Swift
ing --> mq : AMQP/Kafka
tx --> mq
tx --> mstore
tx --> rstore
tx --> pg
ia --> mq
ia --> mstore
ia --> es
deliv --> rstore
deliv --> cache
api --> pg
api --> es
api --> vault
@enduml
\end{verbatim}

\paragraph{Secuencia de ingesta y publicación}
\begin{verbatim}
@startuml
actor Editor
Editor -> API Gateway: Auth (OIDC) + Upload request
API Gateway -> Ingesta Service: iniciar ingesta
Ingesta Service -> Bucket Maestros: upload chunked/resumable
Ingesta Service -> Cola: enqueue transcode+IA
Cola -> Transcode Worker: tarea transcode
Transcode Worker -> Bucket Maestros: lee máster
Transcode Worker -> Bucket Rendiciones: escribe rendición
Transcode Worker -> Metadata Service: registra rendición
Metadata Service -> PostgreSQL: persiste
Transcode Worker -> Cola: evento indexación
Cola -> IA Worker: tarea IA
IA Worker -> Bucket Maestros: lee máster
IA Worker -> Metadata Service: guarda resultados
IA Worker -> OpenSearch: indexa campos semánticos
Editor -> API Gateway: busca/solicita reproducción
API Gateway -> Search Service: consulta
Search Service -> OpenSearch: query
API Gateway -> Delivery Service: solicitar URL firmada
Delivery Service -> Bucket Rendiciones: genera URL HLS/DASH
API Gateway -> Editor: URL firmada
Editor -> Cache/Edge: reproduce contenido
@enduml
\end{verbatim}

